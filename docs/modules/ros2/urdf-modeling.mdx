---
title: URDF for Humanoid Robots
sidebar_position: 4
description: Creating and validating URDF models for humanoid robots in ROS 2
---

# URDF for Humanoid Robots

## Overview

Unified Robot Description Format (URDF) is the standard XML-based format for representing robot models in ROS. For humanoid robots, URDF provides a comprehensive framework to describe the robot's physical structure, including links (rigid bodies), joints (connections between links), and associated properties like mass, inertia, and visual appearance. This chapter explores how to create and validate URDF models specifically for humanoid robots, which have unique characteristics such as bipedal locomotion, multiple degrees of freedom, and complex kinematic chains.

Humanoid robots present specific challenges in URDF modeling due to their anthropomorphic structure, which typically includes a head, torso, two arms, and two legs. Each of these components must be accurately represented to enable proper simulation, visualization, and control. The URDF description serves as the foundation for robot state publishing, forward kinematics, inverse kinematics, and motion planning.

## URDF in the ROS 2 Ecosystem

In ROS 2, URDF models are used by various components:

- **Robot State Publisher**: Publishes the robot's joint states and transforms
- **RViz**: Visualizes the robot model in 3D
- **Gazebo/other simulators**: Provides the physical model for simulation
- **MoveIt**: Uses the model for motion planning and collision detection
- **Controllers**: Reference the model for kinematic calculations

Understanding how to properly structure URDF files is crucial for effective robot development and deployment in the ROS 2 ecosystem.

## Key Components of Humanoid URDF

Humanoid robot URDF models typically include:

- **Links**: Represent rigid bodies like torso, head, limbs
- **Joints**: Define connections between links with specific kinematic properties
- **Materials**: Define visual appearance properties
- **Inertial properties**: Mass, center of mass, and inertia tensor for each link
- **Visual and collision geometries**: Shapes for visualization and collision detection

## Design Principles for Humanoid URDF

When creating URDF models for humanoid robots, consider these principles:

- **Kinematic accuracy**: Ensure the kinematic chain matches the physical robot
- **Mass distribution**: Accurately represent the robot's mass properties
- **Collision detection**: Include appropriate collision geometries
- **Visual representation**: Provide clear visual models for debugging
- **Scalability**: Design the model to accommodate different robot configurations

## Links in URDF

### Concept and Purpose

A **link** in URDF represents a rigid body with specific physical properties. In humanoid robots, links correspond to physical components such as the torso, head, arms, legs, and feet. Each link has associated properties including mass, center of mass, and inertia tensor, which are critical for accurate simulation and control.

Links serve as the building blocks of the robot model, defining the physical structure that will be used for:
- Collision detection in simulation
- Visualization in RViz
- Kinematic calculations
- Dynamic simulation

### Link Structure

A basic link definition in URDF includes:

```xml
<link name="link_name">
  <inertial>
    <origin xyz="0 0 0" rpy="0 0 0"/>
    <mass value="1.0"/>
    <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>
  </inertial>
  <visual>
    <origin xyz="0 0 0" rpy="0 0 0"/>
    <geometry>
      <box size="0.1 0.1 0.1"/>
    </geometry>
    <material name="blue">
      <color rgba="0 0 1 1"/>
    </material>
  </visual>
  <collision>
    <origin xyz="0 0 0" rpy="0 0 0"/>
    <geometry>
      <box size="0.1 0.1 0.1"/>
    </geometry>
  </collision>
</link>
```

### Components of a Link

1. **Inertial**: Defines the mass properties needed for dynamic simulation
   - `origin`: Position and orientation of the center of mass relative to the link frame
   - `mass`: Mass of the link in kilograms
   - `inertia`: Inertia tensor values (ixx, ixy, ixz, iyy, iyz, izz)

2. **Visual**: Defines how the link appears in visualization tools
   - `origin`: Position and orientation of the visual geometry relative to the link frame
   - `geometry`: Shape of the visual representation (box, cylinder, sphere, mesh)
   - `material`: Color and appearance properties

3. **Collision**: Defines the collision geometry for physics simulation
   - `origin`: Position and orientation of the collision geometry relative to the link frame
   - `geometry`: Shape used for collision detection (often simpler than visual geometry)

### Humanoid-Specific Link Considerations

When modeling humanoid robots, consider these link-specific aspects:

- **Head Link**: Should include appropriate inertial properties and visual representation for the head
- **Torso Link**: Often the heaviest link, affecting overall robot stability
- **Limb Links**: Should have appropriate mass distribution based on the actual limb composition
- **Foot Links**: Critical for balance calculations and ground contact

### Example: Humanoid Torso Link

```xml
<link name="torso">
  <inertial>
    <origin xyz="0.0 0.0 0.3" rpy="0 0 0"/>
    <mass value="15.0"/>
    <inertia ixx="0.8" ixy="0.0" ixz="0.0" iyy="0.8" iyz="0.0" izz="0.4"/>
  </inertial>
  <visual>
    <origin xyz="0.0 0.0 0.3" rpy="0 0 0"/>
    <geometry>
      <cylinder radius="0.15" length="0.6"/>
    </geometry>
    <material name="gray">
      <color rgba="0.5 0.5 0.5 1.0"/>
    </material>
  </visual>
  <collision>
    <origin xyz="0.0 0.0 0.3" rpy="0 0 0"/>
    <geometry>
      <cylinder radius="0.15" length="0.6"/>
    </geometry>
  </collision>
</link>
```

This example shows a simplified torso link with appropriate inertial properties for a humanoid robot, using a cylindrical shape for both visual and collision representation.

## Joints in URDF

### Concept and Purpose

A **joint** in URDF defines the connection between two links, specifying the degrees of freedom and constraints for their relative motion. In humanoid robots, joints correspond to physical joints such as shoulders, elbows, hips, knees, and ankles. Joints are critical for defining the robot's kinematic structure and enabling motion planning and control.

Joints serve to:
- Define the kinematic chain of the robot
- Specify the type of motion allowed between links
- Provide limits and constraints for safe operation
- Enable forward and inverse kinematics calculations

### Joint Types

URDF supports several joint types, each appropriate for different kinds of motion:

1. **Revolute**: Rotational joint with a limited range of motion
   - Used for joints like elbows and knees
   - Has position limits in radians

2. **Continuous**: Rotational joint without limits
   - Used for joints that can rotate continuously like some shoulders
   - No position limits

3. **Prismatic**: Linear sliding joint
   - Used for linear actuators or telescoping mechanisms
   - Has position limits in meters

4. **Fixed**: No motion allowed between links
   - Used to rigidly connect two links
   - No limits needed

5. **Floating**: Six degrees of freedom (3 translation + 3 rotation)
   - Used for free-floating objects in simulation
   - Rarely used in actual robot models

6. **Planar**: Motion constrained to a plane
   - Used for specialized applications
   - Rarely used in humanoid robots

### Joint Structure

A basic joint definition in URDF includes:

```xml
<joint name="joint_name" type="revolute">
  <parent link="parent_link_name"/>
  <child link="child_link_name"/>
  <origin xyz="0 0 0" rpy="0 0 0"/>
  <axis xyz="0 0 1"/>
  <limit lower="-1.57" upper="1.57" effort="100" velocity="1.0"/>
  <dynamics damping="0.1" friction="0.0"/>
</joint>
```

### Components of a Joint

1. **Parent and Child**: Define the two links that the joint connects
   - `parent`: The link that is closer to the robot base/root
   - `child`: The link that is further from the robot base/root

2. **Origin**: Position and orientation of the joint frame relative to the parent link frame
   - `xyz`: Position offset (x, y, z) in meters
   - `rpy`: Orientation offset (roll, pitch, yaw) in radians

3. **Axis**: Defines the axis of motion for the joint
   - Specified as a unit vector (x, y, z)
   - For revolute joints, this is the axis of rotation
   - For prismatic joints, this is the direction of linear motion

4. **Limit**: Defines constraints on joint motion
   - `lower`: Minimum position limit
   - `upper`: Maximum position limit
   - `effort`: Maximum effort/torque (N-m for revolute, N for prismatic)
   - `velocity`: Maximum velocity (rad/s for revolute, m/s for prismatic)

5. **Dynamics**: Defines physical properties affecting motion
   - `damping`: Damping coefficient
   - `friction`: Static friction coefficient

### Humanoid-Specific Joint Considerations

When modeling humanoid robots, consider these joint-specific aspects:

- **Degrees of Freedom**: Humanoid joints often have multiple DOF (e.g., shoulders: 3 DOF)
- **Joint Limits**: Set realistic limits based on human anatomy or robot capabilities
- **Actuator Constraints**: Define appropriate effort and velocity limits
- **Safety Margins**: Include safety margins in joint limits to prevent damage

### Example: Humanoid Hip Joint

```xml
<joint name="left_hip_yaw" type="revolute">
  <parent link="torso"/>
  <child link="left_thigh"/>
  <origin xyz="0.0 -0.1 -0.1" rpy="0 0 0"/>
  <axis xyz="0 0 1"/>
  <limit lower="-0.5" upper="0.5" effort="200" velocity="2.0"/>
  <dynamics damping="1.0" friction="0.1"/>
</joint>

<joint name="left_hip_roll" type="revolute">
  <parent link="left_thigh"/>
  <child link="left_thigh_roll_link"/>
  <origin xyz="0.0 0.0 0.0" rpy="0 0 0"/>
  <axis xyz="1 0 0"/>
  <limit lower="-0.4" upper="1.0" effort="200" velocity="2.0"/>
  <dynamics damping="1.0" friction="0.1"/>
</joint>

<joint name="left_hip_pitch" type="revolute">
  <parent link="left_thigh_roll_link"/>
  <child link="left_shin"/>
  <origin xyz="0.0 0.0 -0.3" rpy="0 0 0"/>
  <axis xyz="0 1 0"/>
  <limit lower="-2.3" upper="0.6" effort="300" velocity="1.5"/>
  <dynamics damping="1.0" friction="0.1"/>
</joint>
```

This example shows a simplified 3-DOF left hip joint structure for a humanoid robot, with yaw, roll, and pitch joints to enable realistic leg movement. Note the use of an intermediate link (`left_thigh_roll_link`) to properly orient the joints in 3D space.

## Transmissions in URDF

### Concept and Purpose

**Transmissions** in URDF define the mapping between actuators (motors) and joints. They specify how actuator commands and feedback are transformed to joint commands and feedback. While not always required for basic simulation, transmissions are essential for:
- Hardware interface with real robots
- Control system integration
- Accurate simulation of actuator behavior
- Mapping between actuator and joint space

In ROS 2, transmissions are particularly important when using ros2_control, which provides a standardized framework for robot control.

### Transmission Types

URDF supports different types of transmissions, with the most common being:

1. **Simple Transmission**: Maps one actuator to one joint (most common)
2. **Differential Transmission**: Maps two actuators to one joint or one actuator to two joints
3. **Four-Bar Linkage Transmission**: Maps one actuator to two joints with specific geometric relationships

### Transmission Structure

A basic transmission definition in URDF includes:

```xml
<transmission name="joint1_transmission">
  <type>transmission_interface/SimpleTransmission</type>
  <joint name="joint1">
    <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
  </joint>
  <actuator name="joint1_motor">
    <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
    <mechanicalReduction>1</mechanicalReduction>
  </actuator>
</transmission>
```

### Components of a Transmission

1. **Type**: Specifies the transmission type
   - `transmission_interface/SimpleTransmission`: Standard 1:1 mapping
   - `transmission_interface/DifferentialTransmission`: Differential mapping
   - Other specialized types as needed

2. **Joint**: Defines the joint that the transmission connects to
   - `name`: Name of the joint (must match a joint in the URDF)
   - `hardwareInterface`: Interface type (PositionJointInterface, VelocityJointInterface, EffortJointInterface)

3. **Actuator**: Defines the actuator properties
   - `name`: Name of the actuator
   - `hardwareInterface`: Interface type matching the joint
   - `mechanicalReduction`: Gear ratio between actuator and joint

### Hardware Interfaces

The hardware interface specifies the type of control available:
- `PositionJointInterface`: Position control
- `VelocityJointInterface`: Velocity control
- `EffortJointInterface`: Torque/force control
- `ImuSensorInterface`: For IMU sensors

### Humanoid-Specific Transmission Considerations

When modeling humanoid robots, consider these transmission-specific aspects:

- **Multiple Interface Types**: Humanoid robots may need different control types for different joints
- **Gear Ratios**: Include appropriate mechanical reduction values
- **Safety Limits**: Define limits that match the physical actuators
- **ROS 2 Control Integration**: Structure transmissions for use with ros2_control

### Example: Humanoid Leg Transmission

```xml
<transmission name="left_knee_transmission">
  <type>transmission_interface/SimpleTransmission</type>
  <joint name="left_knee">
    <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>
  </joint>
  <actuator name="left_knee_motor">
    <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>
    <mechanicalReduction>100</mechanicalReduction>
  </actuator>
</transmission>

<transmission name="left_ankle_transmission">
  <type>transmission_interface/SimpleTransmission</type>
  <joint name="left_ankle">
    <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
  </joint>
  <actuator name="left_ankle_servo">
    <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
    <mechanicalReduction>50</mechanicalReduction>
  </actuator>
</transmission>
```

This example shows transmissions for a humanoid leg, with different control interfaces for different joints. The knee joint uses effort control (torque control) which is appropriate for joints that need to handle variable loads, while the ankle uses position control which is suitable for precise positioning tasks.

## Kinematic Modeling in URDF

### Forward Kinematics

**Forward kinematics** is the process of calculating the position and orientation of the robot's end-effectors based on the joint angles. In URDF, the kinematic chain is defined by the sequence of links and joints, allowing ROS 2 tools to automatically compute forward kinematics.

The forward kinematics computation uses:
- Joint types (revolute, prismatic, etc.)
- Joint angles/positions
- Link transformations
- Denavit-Hartenberg parameters (implicitly defined by URDF joint origins)

For a humanoid robot, forward kinematics enables:
- Calculating hand positions from shoulder, elbow, and wrist joint angles
- Determining foot positions from hip, knee, and ankle joint angles
- Visualizing the robot's pose in RViz
- Collision detection in simulation

### Inverse Kinematics

**Inverse kinematics** is the process of determining the joint angles required to achieve a desired end-effector position and orientation. While URDF itself doesn't implement inverse kinematics, it provides the kinematic structure that inverse kinematics solvers need.

ROS 2 packages like MoveIt use the URDF model to:
- Solve for joint angles to reach a target position
- Plan collision-free paths
- Generate motion trajectories
- Handle kinematic constraints

### Kinematic Chains in Humanoid Robots

Humanoid robots have multiple kinematic chains:
- **Left Arm Chain**: base_link → left_shoulder → left_elbow → left_wrist
- **Right Arm Chain**: base_link → right_shoulder → right_elbow → right_wrist
- **Left Leg Chain**: base_link → left_hip → left_knee → left_ankle
- **Right Leg Chain**: base_link → right_hip → right_knee → right_ankle

Each chain must be properly defined in the URDF with correct parent-child relationships.

### Kinematic Constraints

URDF supports various kinematic constraints through joint limits:
- Position limits (min/max joint angles)
- Velocity limits
- Effort limits

These constraints ensure that the robot operates within safe and physically possible ranges.

### Example: Kinematic Chain Definition

```xml
<!-- Left arm kinematic chain -->
<joint name="left_shoulder_joint" type="revolute">
  <parent link="torso"/>
  <child link="left_upper_arm"/>
  <origin xyz="0.1 0.1 0.4" rpy="0 0 0"/>
  <axis xyz="0 1 0"/>
  <limit lower="-1.57" upper="1.57" effort="50" velocity="2.0"/>
</joint>

<joint name="left_elbow_joint" type="revolute">
  <parent link="left_upper_arm"/>
  <child link="left_lower_arm"/>
  <origin xyz="0 0 -0.3" rpy="0 0 0"/>
  <axis xyz="0 1 0"/>
  <limit lower="-2.0" upper="0.5" effort="30" velocity="2.0"/>
</joint>

<joint name="left_wrist_joint" type="revolute">
  <parent link="left_lower_arm"/>
  <child link="left_hand"/>
  <origin xyz="0 0 -0.2" rpy="0 0 0"/>
  <axis xyz="0 1 0"/>
  <limit lower="-1.57" upper="1.57" effort="20" velocity="2.0"/>
</joint>
```

This example shows a simple left arm kinematic chain with proper parent-child relationships that allow forward and inverse kinematics calculations.

### Kinematic Validation

To ensure proper kinematic modeling:
- Verify all joints have correct parent and child links
- Check that joint axes are properly oriented
- Validate joint limits are realistic
- Test reachability of target poses
- Confirm the kinematic chain matches the physical robot

## Best Practices for Humanoid URDF

### File Organization

Organize your URDF files for clarity and maintainability:

1. **Group by function**: Group links and joints by body parts (head, torso, arms, legs)
2. **Consistent naming**: Use consistent naming conventions (e.g., left_arm_upper, left_arm_lower)
3. **Logical ordering**: Order elements logically (materials, base link, then other links and joints)
4. **Comments**: Add comments to explain complex sections

### Inertial Properties

Accurate inertial properties are crucial for simulation:

- Use CAD software to calculate mass and inertia properties
- Ensure the center of mass is correctly positioned
- Use the parallel axis theorem when needed
- Validate that total robot mass is realistic

### Visual and Collision Geometries

For effective visualization and collision detection:

- Use simple shapes for collision geometries to improve performance
- Use detailed meshes for visual geometries when needed
- Ensure visual and collision geometries are properly aligned
- Consider using separate files for complex meshes

### Joint Configuration

For proper joint behavior:

- Set realistic joint limits based on physical constraints
- Choose appropriate joint types (revolute vs continuous)
- Set proper joint axes for desired motion
- Include safety margins in joint limits

### Example: Complete Humanoid Structure

A complete humanoid URDF structure follows this pattern:

```xml
<?xml version="1.0"?>
<robot name="humanoid_robot">
  <!-- Materials -->
  <material name="blue">...</material>
  <!-- More materials -->

  <!-- Base Link -->
  <link name="base_link">
    <!-- Inertial, visual, collision -->
  </link>

  <!-- Head -->
  <link name="head">
    <!-- Inertial, visual, collision -->
  </link>
  <joint name="head_joint" type="fixed">
    <!-- Joint definition -->
  </joint>

  <!-- Left Arm -->
  <link name="left_upper_arm">
    <!-- Inertial, visual, collision -->
  </link>
  <link name="left_lower_arm">
    <!-- Inertial, visual, collision -->
  </link>
  <joint name="left_shoulder_joint" type="revolute">
    <!-- Joint definition -->
  </joint>
  <joint name="left_elbow_joint" type="revolute">
    <!-- Joint definition -->
  </joint>

  <!-- Right Arm -->
  <!-- Similar to left arm -->

  <!-- Left Leg -->
  <link name="left_upper_leg">
    <!-- Inertial, visual, collision -->
  </link>
  <link name="left_lower_leg">
    <!-- Inertial, visual, collision -->
  </link>
  <link name="left_foot">
    <!-- Inertial, visual, collision -->
  </link>
  <joint name="left_hip_joint" type="revolute">
    <!-- Joint definition -->
  </joint>
  <joint name="left_knee_joint" type="revolute">
    <!-- Joint definition -->
  </joint>
  <joint name="left_ankle_joint" type="revolute">
    <!-- Joint definition -->
  </joint>

  <!-- Right Leg -->
  <!-- Similar to left leg -->

  <!-- Transmissions -->
  <transmission name="...">
    <!-- Transmission definition -->
  </transmission>
  <!-- More transmissions -->

</robot>
```

This structure provides a complete humanoid robot model with proper kinematic chains, inertial properties, and control interfaces.

## URDF Validation and Usage in ROS 2

### Validation Tools

ROS 2 provides several tools to validate URDF models:

#### 1. check_urdf Command

The `check_urdf` command is the primary tool for validating URDF syntax and structure:

```bash
# Check a URDF file
check_urdf /path/to/robot.urdf

# Check a URDF with xacro processing
xacro robot.xacro | check_urdf /dev/stdin
```

This tool will report:
- Syntax errors in the URDF file
- Missing parent/child relationships
- Invalid joint types or parameters
- Kinematic chain information

#### 2. xacro Validation

For URDF files that use xacro (XML macros), validate with:

```bash
# Check xacro syntax
xacro --check-order robot.xacro

# Convert xacro to URDF and check
xacro robot.xacro > robot.urdf && check_urdf robot.urdf
```

#### 3. RViz Visualization

Visual validation in RViz helps identify:
- Link placement and orientation
- Joint movement ranges
- Collision vs visual geometry alignment
- Material and color issues

### Loading URDF in ROS 2

#### Robot State Publisher

The Robot State Publisher node loads the URDF and publishes joint transforms:

```xml
<!-- In launch file -->
<node pkg="robot_state_publisher" exec="robot_state_publisher" name="robot_state_publisher">
  <param name="robot_description" value="$(var urdf_file)"/>
</node>
```

#### Parameter Server

URDF is typically loaded as a parameter named `robot_description`:

```python
# In Python node
robot_desc = self.get_parameter('robot_description').value
```

```cpp
// In C++ node
std::string robot_desc = this->get_parameter("robot_description").as_string();
```

### Common Validation Procedures

#### 1. Syntax Validation
- Run `check_urdf` to verify XML syntax
- Check for properly closed tags
- Validate attribute values

#### 2. Kinematic Validation
- Verify all joints have valid parent and child links
- Check that the kinematic chain is connected
- Validate joint limits and types

#### 3. Inertial Validation
- Ensure all links have inertial elements
- Verify mass values are positive
- Check that inertia tensors are physically valid

#### 4. Visual/Collision Validation
- Confirm all links have visual elements for display
- Verify collision elements exist for simulation
- Check that geometries are properly defined

### Example: Validation Workflow

```bash
# 1. Validate syntax
check_urdf examples/ros2/urdf/humanoid.urdf

# 2. Check xacro if used
xacro --check-order examples/ros2/urdf/humanoid.xacro

# 3. Visualize in RViz
ros2 launch urdf_tutorial display.launch.py model:=examples/ros2/urdf/humanoid.urdf

# 4. Test with robot state publisher
ros2 run robot_state_publisher robot_state_publisher --ros-args -p robot_description:=$(cat examples/ros2/urdf/humanoid.urdf)
```

### Troubleshooting Common Issues

#### Invalid Inertial Elements
- Ensure all 6 inertia values (ixx, ixy, ixz, iyy, iyz, izz) are provided
- Verify inertia tensor is physically valid (positive definite)

#### Joint Limit Issues
- Check that lower < upper for revolute joints
- Ensure effort and velocity limits are positive

#### Link Connection Problems
- Verify every link (except the base) has a parent joint
- Check that parent/child relationships are consistent

### Integration with ROS 2 Ecosystem

Valid URDF models integrate with various ROS 2 tools:

- **RViz**: For visualization and debugging
- **Gazebo/Hector**: For physics simulation
- **MoveIt**: For motion planning
- **TF2**: For coordinate transforms
- **ros2_control**: For hardware interfaces